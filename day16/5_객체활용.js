/*
    - 사원 정보와 각 사원의 연도별 점수평가 메모리 구성
    1. 저장할 데이터들을 모두 생각한다
        - 사원명, 생년월일, 연도, 상반기점수, 하반기점수
    2. 데이터들의 관계성 파악 후 정리하기
        - 사원정보(사원명,생년월일), 점수(연도,상반기점수,하반기점수)
        - 상하관계 (일 대 다 관계) 하나의 데이터가 다른 데이터에서 여러개를 참조한다
            누가 먼저 존재해야 하는지 파악
            하나의 사원이 여러 연도의 점수를 가질 수 있다.
                '유재석' -------> 2024  100  90
                         -------> 2023  85  64
                    일      대          다
                => 사원 --> 점수
            ex) 하나의 회원이 여러개의 게시물을 작성할 수 있다. => 회원 --> 게시물
                하나의 카테고리에 여려개의 제품을 등록할 수 있다. => 카테고리 --> 제품
    3. 데이터 분류간의 관계성 연결
        - 사원정보(상위/식별가능한필드), 점수정보(하위)
            1. 유재석 정보 등록 , 유재석 2002-10-02
            2. 유재석 2024점수 등록 , 유재석 2002-10-02 2024 90 80
            3. 유재석 2023점수 등록 , 유재석 2002-10-02 2024 90 80 2023 100 97
                유재석 2002-10-02   ---> 2024 90 80
                                   ---> 2023 100 97
                1 유재석 2002-10-02 ---> 1 2024 90 80
                                   ---> 1 2023 100 97
*/  

// [1] 객체지향으로 메모리 구성
    // (1) 두 사원의 객체 정보를 샘플화해서 2개의 객체 생성
let 사원1 = {no : 1, name : '유재석', birth : '2000-10-02'}
let 사원2 = {no : 2, name : '강호동', birth : '1980-01-25'}
    // (2) 사원목록 등록
let 사원목록 = []
사원목록.push(사원1); // 사원1 등록
사원목록.push(사원2); // 사원2 등록
console.log(사원목록); // 현재 전체 사원의 정보 전체 출력
    // (3) 유재석의 2024 평가 등록
let 점수1 = {no : 1, year : '2024', first : 100, second : 80}; // 유재석의 2024 평가 등록
let 점수2 = {no : 2, year : '2024', first : 92, second : 71}; // 강호동의 2024 평가 등록
let 점수3 = {no : 1, year : '2023', first : 82, second : 97}; // 강호동의 2024 평가 등록
    // (4) 평가 목록 등록
let 평가목록 = []
평가목록.push(점수1);
평가목록.push(점수2);
평가목록.push(점수3);
console.log(평가목록); // 평가 목록내 세번재 위치한 점수는 누구의 점수인가요? => '유재석'